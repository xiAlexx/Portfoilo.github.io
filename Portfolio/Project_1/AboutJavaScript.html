<!DOCTYPE html>
<html lang="en">

    <head>

      <meta charset="UTF-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
               
    <link rel="stylesheet" type="text/css" href="CSS/normalize.css">
    <link rel="stylesheet" type="text/css" href="CSS/mystylesheet.css">
    

    <title> AboutJavaScript </title>

    <nav>
        <ul class="navbarlist">
            <li class="liright"><a target="_blank" href="AboutHTML.html">HTML</a></li>
            <li class="liright"><a target="_blank" href="AboutCSS3.html">CSS3</a></li>
            <li class="liright"><a target="_parent" href="#one">JavaScirpt Introduction</a></li>
            <li class="liright"><a target="_parent" href="#two">JavaScirpt Outputs</a></li>
            <li class="liright"><a target="_parent" href="#three">Conditional Statements</a></li>
            <li class="liright"><a target="_parent" href="#four">Operators</a></li>
            <li class="liright"><a target="_parent" href="#five">Functions</a></li>

        </ul>
    </nav>
<style>
    
    #code {
        background-color: lightgray;
        color: red;
        font-style: italic;
    }

    .navbarlist {
            list-style-type:none;
            overflow: auto;
            background-color: white;
            text-align:left;
            font-size: 1.0em;
        }
        
        .navbarlist a:hover { 
            text-decoration: underline;
            width: 100px; 
            padding: 10px 10px;
            margin: 10px;
        }
        
        .liright {
            float:left;
            color: blue;
            line-height: 10px;
            padding: 10px;
        }
    
</style>
        
</head>
<body>
        <h1 id="one" >JavaScript Introduction</h1>
    
    <p>You may notice most of this information will be a repeat of <a target="_blank" href="www.w3schools.org">W3Schools.org</a> Javascript however all coding done on this web page will of been created by myself and not just copied and paste.</p>
    
    <p>Javascript is one of the 3 languages all web developers <b>must</b> learn:</p>
<ol>
    <li><a target="_blank" href="AboutHTML.html.html">HTML</a> - to define the content of web pages.</li>
    <li><a target="_blank" href="AboutCSS3.html">CSS</a> - to specify the layout of web pages.</li>
    <li>JavaScript - to program the behavior of web pages.</li>
</ol>
    
<h2>What Can JavaScript Do?</h2>
    
    <p>JavaScript can change HTML content. One of many JavaScript HTML methods is <span id="code">getElementById()</span> The example below "finds" an HTML element with (with id="demo"), and changes the element content (innerHRML) to "Hello JavaScript":</p>
    
    <p id="content">JavaScript can change HTML content</p>
 

    <button type="button" onclick='document.getElementById("content").innerHTML = "Hello JavaScript!"'>Click Me!
    </button>

    
    <p>JavaScript can change HTML attribute values.</p>
    
    <p>In this case JavaScript changes the value of the src (source) attribute of an image.</p>

    
    <button type="button" onclick="document.getElementById('myImage').src='Images/bulb-on.jpeg'">Turn on the light</button>


    <img id="myImage" src="Images/bulb-on.jpeg" style="width:100px;">
    
    
    <button type="button" onclick="document.getElementById('myImage').src='Images/pic_bulboff.gif'">Turn off the light</button>
    
    
    <p id="css"> JavaScript can also change the style of an HTML element.</p>
    
  
    <button type="button" onclick="document.getElementById('css').style.fontSize='35px'">Click To Change Style!</button>

    
    <p id="hide">JavaScript can show and hide HTML elements.</p>
    

    <button type="button" onclick="document.getElementById('hide').style.display='none'">Click To Hide Text!</button>
    
    <button type="button" onclick="document.getElementById('hide').style.display='block'">Click To Show!</button>
  
<h2>The Script Tag</h2>
    
    <p>In HTML, JavaScript code is inserted between the <span id="code">Script</span> tags. Old JavaScirpt examples may use a type of attribute: <span id="code">script type="text/Javascript."></span> The type attribute is not required. JavaScript is the default scripting language in HTML. Placing scripts at the bottom of the body element improves the display speed, because script interpretation slows down the display.</p>
        
    <p>Scripts can also be placed in external files like CSS, this is practical when the same code is used in many different web pages. JavaScript files have the file extension <b>.js</b>.
    </p>
    
    <p id="external">Hello World (example of external .js)</p>
    
    <button type="button" onclick="myFunction()">Click  here to try link to a external .js</button>
    
    <p>Placing scripts in external files has some advantages:
    </p>
    
<ul>
    <li>It separates HTML and code.</li>
    <li>It makes HTML and JavaScript easier to read and maintain.</li>
    <li>Cached JavaScript files can speed up page loads time.</li>
</ul>
    
    <p>An external reference can be referenced in 3 different ways:</p>
    
<ol>
    <li>With a full URL. (a full web address)</li>
    <li>With a file path. (like /js/)</li>
    <li>Without any path.</li>
</ol>
    
<h1 id
="two">JavaScript Output</h1>
    
    <p>JavaScript can "display" data in different ways:</p>
    
<ul>
    <li>Wiriting into an HTML element using <span id="code">innerHTML</span>.</li>
    <li>Writing into the HTML output using <span id="code">document.write()</span></li>
    <li>Writing into an alert box, using <span id="code">window.alert()</span></li>
    <li>Writing into the browser console, using <span id="code">console.log()</span></li>
</ul>
    
    <h2>Using innerHTML</h2>
    
    <p>To access an HTML element, JavaScript can use the <span id="code">document.getElementById(id)</span> method. The <span id="code">id</span> defines the HTML element. The <span id="code">innerHTML</span> property defines the HTML content.</p>
    
    <h2>Using Window.alert()</h2>
    
    <p id="alert">Using window alert will display data in a windowed box. Below I have programmed the button to answer the question 5+5 and give the answer in a windowed box once clicked:</p>
    
    <button
            type="button" onclick="windowalert()">Click Here!
    </button>
    
    //This isnt completed consolelog() neeeds to be put in.
    
<h1 id="three">Conditional Statements</h1>
    
            <p>In life, we make decisions based on circumstances. 
            Think of an everyday decision as mundane as falling asleep — if we are tired, we go to bed, otherwise,
             we wake up and start our day.
            These if-else decisions can be modeled in code by creating conditional statements. 
            A conditional statement checks a specific condition(s) and performs a task based on the condition(s).
            </p>
    
            <p>An example of this can be seen below</p>
            <img src="Images/controlFlow.svg" title="A template of control flow." class="imgcenter"> 

            <p> We often perform a task based on a condition. For example, if the weather is nice today,
                then we will go outside. If the alarm clock rings, then we will shut it off. If we are tired,
                then we will go to sleep.
            </p>

            <p> In programming, we can also perform a task based 
                on a condition using an <span id='code'>IF</span>
                statement.
            </p>
            <img src="Images/IfStatement.png" title="If_statement example" alt="Example of an If statement" class="imgcenter">            
            <p> Notice in the example above, we have an <span id="code">IF</span> statement. The 
                <span id='code'>IF</span> statement is composed of:
            </p>
            
            <ul>
                <li> The <span id="code">IF</span> keyword follwed by a set of a parentheses 
                    <span id="code">()</span> which is followed by a code block, or block statement,
                    indicated by a set of curly braces.
                </li>
                    <br>
                <li> Inside the parentheses, a condition is provided that evaluates to true of false.
                </li>
                    <br>
                <li>If the condition evaluates to true, the code inside the curly braces run, or executes.
                </li>
                    <br>
                <li>If the condition evaluates to false, the block won't execute.
                </li>
            </ul>

            <p> In the example provided above because the variable of 'Age' is equal to 21,
                console will log 'older then 20!', as well as 'older then 15!'.
                If we wanted to add some default behavior to the if statement, we can add an 
                else statement to run a block of code when the condition
                evaluates to false. For more information on If...Else... statements 
                <a target="_blank" href="https://www.w3schools.com/js/js_if_else.asp">Click Here!</a>
            </p>

<h1 id="four">Operators</h1>

            <p> When writing conditional statements, sometimes we need
                to use different types of operators to compare values.
                These operators are called comparison operators.
            </p>

            <p> Here is a list of some handy comparison operators and 
                their syntax:
            </p>

            <ul>
                <li>Less than: < </li>
                    <br>
                <li>Greater than: > </li>
                    <br>
                <li>Less than or equal to: <= </li>
                    <br>
                <li>Greater than or equal to: >= </li>
                    <br>
                <li>Is equal to: === </li>
                    <br>
                <li>Is not eqaul to: !== </li>
            </ul>

            <p> Comparioson operators compare the value on the left with
                the value on the right. 
                
                <br>
                For example:            
                <span id="code"> 10 < 12</span> 
            </p>

            <p>It can be helpful to think of comparison statements 
                as questions. When the answer is "yes", the statement evaluates
                to true, and when the answer is "no", the statement evaluates
                to false. The code above would be asking: is 10 less then 12? Yes!
                So <span id="code"> 10 < 12</span> evaluates to true. We can also use comparison operators
                on different data types like strings:
            </p>
            
            <p> <span id="code"> 'apples' === 'oranges'</span>
                <br>
                This statement would be false.
            </p>

            <p>In the example above, we are using the identity operator <span id="code"> (===)</span> 
                to check if the string 'apples is the same as the string 'oranges'. Since the two
                strings are not the same, the comaprison statement evaluates to false.
                
                <br>
                
                All comparison statments evaluate to either true or false and are made up of:
            </p>

            <ul>
                <li>Two values that will be compared.</li>
                    <br>
                <li>An operator that separates the values and comapres them accordingly
                    (>, <, <=, >=, ===, !==) 
                </li>
            </ul>

        <h2>Logical Operators</h2>

            <p> Working with conditionals means that we will be using booleans, true or false values.
                In JavaScript, there are operators that work with boolean values known as kogical 
                operators. We can use logical operators to add more sophisticated logic to our conditionals.
                There are three logical operators:
            </p>
            <ul>
                <li>the <i>And</i> operator (&&)</li>
                    <br>
                <li>the <i>OR</i> operator (||)</li>
                    <br>
                <li>the <i>not</i> operator, otherwise known as the <i>bang</i> operators (!)</li>
            </ul>
        
        <h2>Ternary Operator</h2>
            
            <p>In the spirit of using short-hand syntax, we can use a ternary operator
                to simplify an <span id="code">if...else</span> statement.
                <br>
                Take a look at the <span id="code">if...else</span> statement example:
            </p>

            <img src="/Images/TenaryOperatorExample.png" title="Example of an ternary operator" alt="An example of an ternary operator" class="imgcenter">

            <p>We can use an ternary operator to perform the same functionality.
                <br>
                    In the example above:
            </p>

            <ul>
                <li>The condition, Age, is provide before the ?.</li>
                    <br>
                <li>Two expressions follow the ? and are separeted by a colon :.</li>
                    <br>
                <li>If the condition evaluates to true, the first expression executes.</li>
                    <br>
                <li>If the condition evaluates to false, the second expression executes.</li>
            </ul>

            <p> Like <span id="code">if...else</span> statements, ternary operators can be used
                for conditions which evaluate to true or false.
            </p>

        <h2>Else If Statements</h2>
            
            <p> We can add more conditions to our <span id="code">if...else</span> with an 
                <a target="_blank" href="https://www.w3schools.com/js/js_if_else.asp">Else if</a> 
                statement. The <span id="code">else if</span> statement allows for more than two 
                possible outcomes. You can add as many <span id="code">else if</span> statements as you would
                like, to make more complex conditionals!
            </p>

            <p> The <span id="code">else if</span> statement always comes after the 
                <span id="code">if</span> statement and before the <span id="code">else</span>
                statement. The <span id="code">else if</span> statement also 
                takes a condition. 
            </p>

            <p>The <span id="code">else if</span> statements allow you to have multiple possible
                outcomes. <span id="code">if</span>/<span id="code">else if</span>/<span id="code">else</span> 
                statements are read from top to bottom, so the first condition that evaluates to true
                from the top to bottom is the block that gets executed. 
            </p>

        <h2>The Switch Keyword</h2>
            
            <p> <span id="code">Else if</span> statements are a great tool if we need to check 
                multiple conditions. In programming, we often find ourselves needing to check 
                multiple values and handling each of them differently, but imagine if we needed to check 100 different values!
                Having to write that many else if statements sounds like a pain!
            </p>

            <p> A switch statement provides an alternative syntax that is easier to read and write. 
                A switch statement looks like this:
            </p>

            <img src="/Images/SwitchTernaryExample.png" class="imgcenter" title="Switch_Example" alt="An example of using the keyword switch.">

            <ul>
                <li> The switch keyword initiates the statement and is followed by ( ... ), which contains the value that each case will compare.
                     In the example, the value or expression of the switch statement is newDate.
                </li>
                    <br>
                <li> Inside the block, there are multiple cases. The case keyword checks if the expression matches the specified value that comes after it.
                     The value following the first case is sunday.
                     If the value of newDate equalled sunday that cases console log would run.
                </li>
                    <br>
                <li> The break keyword tells the computer to exit the block and not execute any more code or check any other cases inside the code block.
                     Note: Without break keywords, the first matching case will run, but so will every subsequent case regardless of whether or not it matches—including the default.
                     This behavior is different from if/else conditional statements that execute only one block of code.
                </li>
                    <br>
                <li> At the end of each switch statement, there is a default statement. 
                     If none of the cases are true, then the code in the default statement will run.
                </li>
            </ul>

    <h1 id="five">Functions</h1>
            
        
        <p> When first learning how to calculate the area of a rectangle, there is a sequence of steps to calculate the correct answer: 
        
            </p>
        
            <ol>
                <li>Measure the width of the rectangle.</li>
                    <br>
                <li>Measure the height of the rectangle.</li>
                    <br>
                <li>Multiply the width and height of the rectangle.</li>
            </ol>

        <p> With practice, you can calculate the area of the rectangle without
            being instructed with these three steps every time. We can calculate the area of
            one rectangle with the following code:
        </p>

        <p><span id="code">
            const width = 10;
                <br>
            const height = 6;
                <br>
            const area =  width * height;
                <br>
            console.log(area); // Output: 60 </span>
        </p>

        <p>Imagine being asked to calculate the area of three different rectangles:
            
            </p>

        <p><span id="code">// Area of the first rectangle
                <br>
            const width1 = 10;
                <br>
            const height1 = 6;
                <br>
            const area1 =  width1 * height1;
                <br>
                <br>
            // Area of the second rectangle
                <br>
            const width2 = 4;
                <br>
            const height2 = 9;
                <br>
            const area2 =  width2 * height2;
                <br>
                <br> 
            // Area of the third rectangle
                <br>
            const width3 = 10;
                <br>
            const height3 = 10;
                <br>
            const area3 =  width3 * height3;
            </span>
        </p>
        
        <p> In programming, we often use code to perform a specific task multiple
            times. Instead of rewriting the same code, we can group a block of code 
            together and associate it with one task, then we can reuse that block of 
            code whenever we need to perform the task again. We achieve this by creating 
            a <i>Function</i>. A function is a reusable block of code that groups together 
            a sequence of statements to perfrom a specific task. 
        </p>

    <h2>Function Declarations</h2>
        
        <p> In JavaScirpt, there are many ways to create a function. One way to create a function 
            is by using a <i>function declaration</i>. Just like how a variable declaration binds 
            a value to a variable name, a function declaration binds a function to a name, 
            or identifier. Take a look at the anatomy of a function declaration below:
        </p>
        
        <img src="Images/FunctionDeclaration.svg" class="imgcenter" title="Anatomy of a function." alt="Anatomy of a function.">

        <p>A function declaration consists of:
            </p>

    <ul>
        <li>The <span id="code">function</span> keyword.</li>
            <br>
        <li>The name of the function, or its identifier, followed by parentheses.</li>
            <br>
        <li>A function body, or the block of statements required to perform a specific task, enclosed in the functions curly bracket. </li>
    </ul>

    <p> A function declaration is a function that is bound to an identifier, or name.
        In the next exercise we will go over how to run the code inside the function body.
    </p>

    <p> We should also be aware of the <i>hoisting</i> feature in JavaScirpt which allows access to function 
        declarations before they are defined.
    </p>

    <p>Take a look at a example of hoisting:
    </p>

    <p><span id="code"> 
        greetWorld(); // Output: Hello, World!
        <br>
        function greetWorld() CurlyBrackets
        <br>
        console.log('Hello, World!');
        ClosedCurlyBrackets
        </span>
    </p>

    <p> Notice how hoisting allowed <span id="code">greetWorld()</span> to be called before the 
        <span id="code">greetWorld()</span> function was defined! Since hositing isn't considered 
        good practice, we simply want you to be aware of this feature.
    </p>

<h2>Calling Functions</h2>

    <p>As we saw in previous exercises, a function a declaration binds a function to an idenifier. 
        <br>
        <br>
        However, a function declaration does not ask the code inside the function body to run, it just declares
        the existence of the function. The code inside function body runs, or executes, only
        when the function is <i>called</i>. 
        <br>
        <br>
        To call a function in your code, you type the function name followed by parentheses.
    </p>
    
    <img src="Images/CallingAFunction.svg" class="imgcenter" title="Calling a function" alt="An example of calling a function">

    <p> This function call executes the function body, or all the statements between the curly 
        braces in the function declaration. We can call the same function as many times as needed.
    </p>

<h2>Parameters And Arguments</h2>

    <p>So far, the functions we've looked at execute a task without an input. However, some functions
        can take inputs and use the inputs to perform a task. When declaring a function, we can specify it's 
        <i>parameters.</i> Parameters allow functions to accpect input(s) and perform a task using the 
        input(s). We use parameters as placeholders for information that will be passed to the function when 
        it is called. 
    </p>

    <a target="_blank" href="https://www.w3schools.com/js/js_function_parameters.asp"><img class="imgcenter" src="Images/ParametersAndArgumentsExample.jpg" title="Parameters And Arguments Example" alt="An example of Parameters And Arguments Example"></a>

    <p>In the diagram above, <span id="code">calculateArea()</span>, computes the area of a rectangle, based on 
        two inputs, <span id="code">width</span> and <span id="code">height</span>. The parameters are specified 
        between the parenthesis as <span id="code">width</span> and <span id="code">height</span> act as placeholders
        for values that will ve multiplied together.
        <br>
        <br>
       When calling a function that has parameters, we specify the values in the parenthesis that follow the function 
        name. The values that are passed to the function when it is called are called <i>arguments</i>. Arguments 
        can bes passed to the function as values or variables. Please note that the order in which arguments are passed 
        and assigned follows the order that the parameters are declared. By using parameters, <span id="code">calculateArea()</span>  
        can be reused to compute the area of any rectangle! Functions are a powerful tool in computer programming.
    </p>

<h2>Default Parameters</h2>

    <p>One of the features added in ES6 is the ability to use <i>default parameters</i>. 
        Defaults parameter allow parameters to have a predeterminded value in case there is no argument passed into the 
        function or if the argument is <span id="code">Undefined</span> when called.
    <br>
    <br>
    </p>

    <p>Take a look at the code snippet below that uses a default parameter:</p>

    <p><span id="code">function greeting (name = 'stranger') {
        <br>
        console.log(`Hello, ${name}!`)
        <br>
      }
        <br>
        <br>
      greeting('Nick') // Output: Hello, Nick!
        <br>
      greeting() // Output: Hello, stranger!
        </span>
        
    </p>

    <ul>
        <li>In the example above, we used the <span id="code">=</span> operator to assign the 
            parameter <span id="code">name</span> a default value of 
            <span id="code">'stranger'</span>. This is useful to have in case we ever want to include 
            a non-personalized default greeting!
            </li>
            <br>
        <li>When the code calls <span id="code">greeting('Nick)</span> the value of the argument is 
            passed in and, <span id="code">'Nick'</span>, will override the default parameter of 
            <span id="code">'stranger'</span> to log <span id="code">'Hello, Nick!'</span> to the console.
            </li>
            <br>
        <li>When there isn't an agrument passed into <span id="code">greeting()</span>, the default value 
            of <span id="code">'stranger</span> is used, and <span id="code">'Hello, stranger!'</span> is 
            logged to the console.
            </li>
    </ul>

    <p>By using a default parameter, we account for situations when an argument isn't passed into a function 
        that is expecting an agrument.
    </p>
    
<h2>Return</h2>

    <p>When a function is called, the computer will run through the function's code and evaluate the result of calling 
        the function. By default that resulting value is <span id="code">undefined</span>.
    </p>

    <p><span id="code">function rectangleArea(width, height) {
        <br>
        let area = width * height;
        <br>
      }
        <br>
        console.log(rectangleArea(5, 7))
        <br> 
        // Prints undefined
    </span>
    </p>

    <p>In the code example, it defined the function to calculate the <span id="code">area</span> 
        of a <span id="code">width</span> and <span id="code">height</span> parameter. Then 
        <span id="code">rectangleArea()</span> is called/invoked with the arguments 
        <span id="code">5</span> and <span id="code">7</span>. But after we print the results we get 
        <span id="code">undefined</span>.
        <br>
        <br> 
        So is this function incorrect?
        <br>
        <br>
        Well No! In fact, the function worked fine, and the computer did calculate the area as 
        <span id="code">35</span>, but we didn't capture it. Which is where the keyword 
        <span id="code">return</span> is needed.
    </p>

    <p><span id="code">function calculateArea(width, height) {
        <br>
        const area = width * height;
        <br>
        return area;
        <br>
      }
    </p>

    <p>To pass back information from the function call, we use a <a href="https://www.w3schools.com/python/ref_keyword_return.asp">return statement</a>.
        To create a return statement, we use the <span id="code">return</span> keyword 
        followed by the value that we wish to return. Like seen above,
        if the value is omitted, <span id="code">undefined</span> is returned instead.
    </p>

    <p>When a <span id="code">return</span> statement is used in a function body, 
        the execution of the function is stopped and the code
        that follows it will not be executed. 
        Look at the example below:
    </p>

    <p><span id="code">function rectangleArea(width, height) {
        <br>
        if (width < 0 || height < 0) {
            <br>
          return 'You need positive integers to calculate area!';
          <br>
        }
        <br>
        return width * height;
        <br>
      }
        </span>
    </p>

    <p>If an argument for <span id="code">width</span> or <span id="code">height</span> 
        is less than <span id="code">0</span>,
        then <span id="code">rectangleArea()</span> will return 
        <span id="code">'You need positive integers to calculate area!'</span>. 
        The second return statement <span id="code">width * height</span> will not run.
    </p>

    <p>The <span id="code">return</span> keyword is powerful 
        because it allows functions to produce an output.
        We can then save the output to a variable for later use.
    </p>

<h2>Helper Functions</h2>

    <p>We can also use the <span id="code">return</span> value of a function 
        inside another function. These functions 
        being called within another function are often
        referred to as helper functions. Since each 
        function is carrying out a specific task, it 
        makes our code easier to read and debug if necessary.
    </p>

    <p>If we wanted to define a function that converts 
        the temperature from Celsius to Fahrenheit,
        we could write two functions like:
    </p>

    <p><span id="code">function multiplyByNineFifths(number) {
        <br>
        return number * (9/5);
        <br>
      };
      <br>
      <br>
       function getFahrenheit(celsius) {
        <br>
        return multiplyByNineFifths(celsius) + 32;
        <br>
      };
        <br>
        <br>            
      getFahrenheit(15); // Returns 59</span>
    </p>

    <p>In the example above:

    </p>

    <p>
        <ul>
            <li><span id="code">getFahrenheit()</span> is called 
                and <span id="code">15</span> is passed as an argument.
            </li>
                <br>
            <li>The code block inside of 
                <span id="code">getFahrenheit()</span> 
                 calls <span id="code">multiplyByNineFifths()</span>
                 and passes <span id="code">15</span> as an argument.
            </li>
                <br>
            <li><span id="code">multiplyByNineFifths()</span> takes 
                 the argument of <span id="code">15</span> for the 
                 <span id="code">number</span> parameter.
            </li>
                <br>
            <li>The code block inside of 
                <span id="code">multiplyByNineFifths()</span> 
                function multiplies <span id="code">15</span> 
                by <span id="code">(9/5), which evaluates to 
                <span id="code">27</span>.
            </li>
                <br>
            <li><span id="code">27</span> is returned back to the function 
                call in <span id="code">getFahrenheit()</span>.
            </li>
                <br>
            <li><span id="code">getFahrenheit()</span> continues to 
                execute. It adds <span id="code">32</span> to 
                <span id="code">27</span>, which evaluates to 
                <span id="code">59</span>.
            </li>
                <br>
            <li>Finally, <span id="code">59</span> is returned back 
                to the function call <span id="code">getFahrenheit(15)</span>.
            </li>
        </ul>
    </p>

    <p>We can use functions to section off small bits of logic or 
        tasks, then use them when we need to. Writing helper 
        functions can help take large and difficult tasks and break 
        them into smaller and more manageable tasks.
    </p>

<h2>Functions Expressions</h2>

    <p>Another way to define a function is to use a function 
        <i>expression</i>. To define a function inside an expression, 
        we can use the <span id="code">function</span> keyword. In a 
        function expression, the function name is usually omitted.
        A function with no name is called an <i>anonymous function</i>.
        A function expression is often stored in a variable in 
        order to refer to it.
    </p>

    <p>Consider the following expression:</p>

    <img src="Images/FunctionExpressionsImageOne.svg" title="Function Expression Example." alt="An image on a function expression convertion." class="imgcenter">

    <p>To declare a function expression:</p>

    <p>
        <ol>
            <li>Declare a variable to make the variables name be the name,
                or identifier, of your function. Since the release of ES6,
                it is common practice to use <span id="code">const</span> as 
                the keyword to declare the variable.
            </li>
                <br>
            <li>Assign as that variable's value an anonymous function created 
                by using the <span id="code">function</span> keyword followed by a set of parentheses 
                with possible parameters. Then a set of curly braces that 
                contain the function body.
            </li>
        </ol>
    </p>

    <p>To invoke a function expression, write the name of the variable 
        in which the function is stored followed by parentheses 
        enclosing any arguments being passed into the function.
    </p>

    <p>
        <span id="code">variableName(argument1, argument2)</span>
    </p>

    <p>Unlike function declarations, function expressions are not 
        hoisted so they cannot be called before they are defined.
    </p>

    <p>Here is an example:</p>

    <p>
        <span id="code">const plantNeedsWater = function(day) {
        <br>
        if (day === 'Wednesday') {
            <br>
          return true;
            <br>
        } else {
            <br>
          return false;
            <br>
        }
            <br>
      };
            <br>
            <br>
      plantNeedsWater('Tuesday');
            <br>
            <br>     
      console.log(plantNeedsWater('Tuesday'))
        </span>
    </p>

<h2>Arrow Functions</h2>

    <p>ES6 introduced arrow function syntax, a shorter way to 
        write functions by using the special “fat arrow” 
        <span id="code">() =></span> notation.
    </p>

    <p>
        <a target="_blank" href="https://www.w3schools.com/js/js_arrow_function.asp">Arrow Functions</a>
        remove the need to type out the keyword <span id="code">function</span> 
        every time you need to create a function. Instead, you first 
        include the parameters inside the <span id="code">( )</span> 
        and then add an arrow <span id="code">=></span> that points 
        to the function body surrounded in <span id="code">{ }</span> 
        like this:
    </p>

    <p><span id="code">const rectangleArea = (width, height) => {
        <br>
        let area = width * height;
        <br>
        return area;
        <br>
      };
      </span>
    </p>

    <p>It's important to be familiar with the multiple ways of 
        writing functions because you will come across each of 
        these when reading other JavaScript code.
    </p>

<h2>Concise Body Arrow Functions</h2>

    <p>JavaScript also provides several ways to refactor arrow 
        function syntax. The most condensed form of the function is 
        known as concise body. We'll explore a few of these techniques 
        below:
    </p>

    <p>
        <ol>
            <li>Functions that take only a single parameter do not need that 
                parameter to be enclosed in parentheses. However, if a 
                function takes zero or multiple parameters, parentheses are 
                required.
            </li>
                <br>
        <img src="Images/parameters.svg" title="Parameters" alt="Parameters Examples" class="imgcenter">
                <br>
            <li>A function body composed of a single-line block does not need curly 
                braces. Without the curly braces, whatever that line evaluates will be 
                automatically returned. The contents of the block should immediately 
                follow the arrow <span id="code">=></span> and the <span id="code">return</span> 
                keyword can be removed. This is referred to as implicit return.
            </li>
                <br>
        <img src="Images/single&multi-line_block.svg" title="Line_Blocks_Example" alt="An example of single and multi-line blocks." class="imgcenter">
        </ol>
    </p>

    <p>So if we have a function:</p>

    <p>
        <span id="code">const squareNum = (num) => {
                <br>
            return num * num;
                <br>
          };
        </span>
    </p>
    
    <p>We can refactor the function to:</p>

    <p><span id="code">Const squareNum = num => num * num</span></p>

    <p>Notice the following changes:</p>

<ul>
    <li>The parentheses arpund <span id="code">num</span>
        have been removed, since it has a single parameter.
    </li>
    <br>
    <li>The curly braces <span id="code">{}</span> have 
        been removed since the function consists of a single-line 
        block.
    </li>
    <br>
</ul>

<h2>Review Functions</h2>

    <p>Give yourself a pat on the back, you just navigated through 
        functions!
    </p>

    <p>In this lesson, we covered some important concepts about functions:</p>

<ul>
    <li>A <i>function</i> is a reusable block of code that groups together a 
        sequence of statements to perform a specific task.
    </li>
    <br>
    <li>A function declaration: </li>
</ul>

    <p><span id="code">function greetWorld() {
        <br>&nbsp;console.log('Hello, World');
        <br>}
    </span></p>

<ul>
    <li>A parameter is a named variable inside a functions block which will be 
        assigned the value of the argument passed in when the function is invoked.
    </li>
    <br>
    <li>We also learned to call a function in your code.</li>
    <br>
    <li>ES6 introduces new ways of handling arbitary parameters through default parameters 
        which allow us to assign a default value to a parameter in case no argument is passed 
        into the function.
    </li>
    <br>
    <li>To return a value from a function, we use a return statement.</li>
    <br>
    <li>To define a function using arrow function notation.</li>
    <br>
    <li>To define a function using function expressions.</li>
    <br>
    <li>We also learned that function definition can be made concise usinf concise arrow notation.</li>
    
</ul>

    <p>It's good to be aware of the differences between function expressions, 
        aroow functions, and function declarations. As you program more in JavaScript, you'll see a 
        wide variety of how these function types are used.
    </p>

<h1>Scope</h1>

    <p>An important idea in programming is <i>scope</i>. Scope defines where variables can be accessed 
        or referenced. While some variables can be accessed from anywhere within a program, other variables 
        may only be available in a specific context.
    </p>

    <p>You can think of scope like the view of the night sky from your window. Everyone who lives on the planet 
        Earth is in the global scope of the stars. The stars are accessible <i>globally</i>. Meanwhile, if you live 
        in a city, you may see the city skyline or the river. The 
        skyline and river are only accessible <i>locally</i> in your city, but you can still see the stars that are 
        available globally.
    </p>

    <p>Over the next few exercises, we'll explore how scope relates to variables and learn best 
        practices for variable declaration.
    </p>

<h2>Blocks and Scope</h2>

    <p>Before we talk more about scope, we first need to talk about <i>blocks</i></p>

    <p>We've seen blocks used before in functions and 
        <span id="code">if</span> statements. A block is code 
        found inside the a set of curly braces <span id="code">{}</span>. 
        Blocks help group one or more statements together and serve as an 
        important marker for code. A block of code could be a function 
        for example:
    </p>
<pre>
<code>
    const logWaterColor = () => {
        let water = 'Blue';
        console.log(color);
        //Prints 'Blue'
    }
</code>
</pre>

    <p>Notice how the function body is actually a block of code.</p>

<h2>Global Scope</h2>

    <p><i>Scope</i> is the context of which variables are declared and can exist either outside of or in <i>Blocks</i></p>

    <p><b>Global Scope</b> has the power to delcare variables outside of blocks. These variabls are call <i>global variables</i>. This means that global scope can be accessed by any code in a program, including code in blocks.</p>

    <p>Lets's take a look at an example I made:</p>
<pre>
<code>
    const water = 'Blue';
        
    const logWaterColor = () => {
        return water;
        //Output is 'Blue' 
    };

    console.log(logWaterColor());
    //Prints 'Blue' to termial
</code>
</pre>

    <p>Notice two things with this example:</p>

    <ol>
        <li>Even though the <span id="code">water</span> variable is declared outside of the block, it can be accessed in the function block, giving it global scope.</li>

        <br>

        <li><span id="code">water</span> can be accessed within the <span id="code">logWaterColor</span> function block.</li>
    </ol>
    
    <p>Find out more about Global Scopes. <a target="_blank" href="https://www.codecademy.com/courses/introduction-to-javascript/lessons/scope/exercises/global-scope">Click here</a></p>

    <h2>Block Scope</h2>

    <p>This content will breifly cover the consept of <i>Block Scope</i> For more information about block scope please vist w3schools you can find the link here:<a target="_blank" href="https://www.w3schools.com/js/js_scope.asp"> w3Schools.com</a></p>

    <p>When a variable is defined inside aa block, it is only accessible to the code within the curly braces. <span id="code">{ }</span>. We say that variable has <i>block scope</i> because it is only accessible to the lines of code within that block.</p>

    <p>Variables that are declared with block scope are known as <i>local variables</i> because they are only available to the code that is part of the same block.</p>

    <p>Block Scope works like this:</p>

    <pre>
    <code>
        const logSkyColor = () => {
            let color = 'blue'; 
            console.log(color); // Prints "blue"
          };
          
          logSkyColor(); // Prints "blue"
          console.log(color); // throws a ReferenceError
    </code>
    </pre>

    <p>You'll notice:</p>

    <ul>
        <li>We define a function <span id="code">logSkyColor()</span>.</li>
        <br>
        <li>Within the function, the <span id="code">color</span> variable is only available within the curly braces of the function.</li>
        <br>
        <li>If we try to log the same variable outside the function, it throws a <span id="code">ReferenceError</span></li>
    </ul>

    <h2>Scope Pollution</h2>

    <p>It may seem like a great idea to always maake your variables accessible, but having too many global variables can cause problems in a program.</p>

    <p>When you declare global variables, they go to the <i>global namespace</i>. The global namespace allows the variables to be accessible from anywhere in the program. These variables remain there untill the program finishes which means our global namespace can fill up really quickly.</p>

    <p>Scope pollution is when we have too many global variables that exist in the global namespace, or when we reuse variables across different scopes. Scope pollution makes it diffivult to kepp track of our different variables and sets us up for potential accidents. I made this same misstake when first making this website. As an example, globally scoped variables can collide with other variables that are more locally scoped, causing unexpected behavior in our code.</p>

    <p>Let's look at an example of scope pollution in practice so we know how to avoid it:</p>

    <pre>
    <code>
        let num = 50;

        const logNum = () => {
            num = 100; // Take note of this line of code
            console.log(num);
        };

        logNum(); // Prints 100
        console.log(num); // Prints 100
    </code>
    </pre>

    <p>Okay so how does this work?</p>

    <ul>
        <li>We have a variable <span id="code">num</span></li>
        <br>
        <li>Inside the function body of <span id="code">logNum()</span>, we want to declare a new variable but forgot to use the <span id="code">let</span> keyword.</li>
        <br>
        <li>When we call <span id="code">logNum()</span>, <span id="code">num</span> gets reassigned to <span id="code">100</span>.</li>
        <br>
        <li>The reassignment inside <span id="code">logNum()</span> affects the global variable <span id="code">num</span>.</li>
        <br>
        <li>Even though the reassignment is allowed and we won't get an error, if we decided to use <span id="code">num</span> later, we'll unknowingly use the new value of <span id="code">num</span></li>
    </ul>

    <p>While it's important to know what global scope is, it's best practice to not define variables in the global scope.</p>

    <h2>Practicing Good Scoping</h2>

    <p>Given the challenges with global variables and scope pollution, we should follow best practices for scoping our variables as tightly as possible using block scope.</p>
    
    <p>Tightly scoping your variables will greatly improve your code in several ways:</p>

    <ul>
        <li>It will make your code more legible since the blocks will organize your code into discrete sections.</li>
        <br>
        <li>It makes your code more understandable since it clarifies which variables are associated with different parts of the program rather then having to keep track of them line after line.</li>
        <br>
        <li>It's easier to maintain your code, since your code will be modular.</li>
        <br>
        <li>It will save memory in your code because it will cease to exist after the block finishes running.</li>
    </ul>

    <p>Here is another example of how block scope works, as defined within an <span id="code">if</span> block:</p>

    <pre>
    <code>
        const logSkyColor = () => {
            const dusk = true;
            let color = 'blue'; 
            if (dusk) {
              let color = 'pink';
              console.log(color); // Prints "pink"
            }
            console.log(color); // Prints "blue"
          };
          
          console.log(color); // throws a ReferenceError  
    </code>
    </pre>

    <p>Here, you'll notice:</p>

    <ul>
        <li>We create a variable <span id="code">color</span> inside the <span id="code">logSkyColor()</span> function.</li>
        <br>
        <li>After the <span id="code">if</span> statement, we define a new code block with the <span id="code">{ }</span> braces. Here we assign a new value to the variable <span id="code">color</span> if the <span id="code">if</span> statement is truthy.</li>
        <br>
        <li>Within the <span id="code">if</span> block, the <span id="code">color</span> variable holds the value <span id="code">pink</span>, though outside the <span id="code">if</span> block, in the function body, the <span id="code">color</span> variable holds the value <span id="code">blue</span>.</li>
        <br>
        <li>On the last line, we attempt to print the value of <span id="code">color</span> outside both the <span id="code">if</span> statement and the definition of <span id="code">logSkyColor()</span>. This will throw a <span id="code">ReferenceError</span> since <span id="code">color</span> only exists within the scope of those two blocks - it is never defined in the global scope.</li>
        <br>
        <li>While we use block scope, we still pollute our namespace by reusing the same variable name twice. A better practice would be to rename the variable inside the block.</li>
        </ul>

        <p>Block scope is a powerful tool in JavaScript, since it allows us to define variables with precision, and not pollute the global namesapce. If a variable does not need to exist outside a block it shouldn't.</p>

        <h1>Arrays</h1>

        <p>Organizing and storing data is a foundational concept of programming.</p>

        <p>One way we organize data in real life is by making lists. Let's make one here:</p>

        <p>New Year's Resolutions:</p>

        <ol>
            <li>Keep a journal</li>
            <br>
            <li>Take a falconry class</li>
            <br>
            <li>Learn to juggle</li>
        </ol>
    
        <p>Let's now write this list in JavaScript, as an array:</p>

        <pre>
        <code>
            let newYearsResolutions = ['Keep a journal', 'Take a falconry class', 'Learn to juggle'];
        </code>
        </pre>

        <p>Arrays are JavaScripts way of making lists. Arrays can store any data types including strings, numbers, and booleans. Like llists, arrays are ordered meaning each item has a numbered position.</p>

        <p>Heres an array of the concepts we'll cover:</p>

        <pre>
        <code>
            let concepts = ['creating arrays', 'array structures', 'array manipulation'];
        </code>
        </pre>

        <p>Understanding arrays is a great tool to have under your belt that helps you manage chucks of data!</p>

        <h2>Creating an Array</h2>

        <p>One way we can create an arrayy is to use an array literal. An array literal creates an array by wrapping items in square brackets <span id="code">[ ]</span>. Remember from the previous section, arrays can store any data type - we can have an array that holds all the same data types or an array that holds different data types.</p>

        <img src="/Portfolio/Project_1/Images/array literal.svg" title="An array literal" alt="An image of an array literal" class="imgcenter">

        <p>Let's take a closer look at the syntax in the array example:</p>

        <ul>
            <li>The array is represented by the square brackets <span id="code">[ ]</span> and the content inside.</li>
            <br>
            <li>Each content item inside an array is called an <i>element</i>.</li>
            <br>
            <li>There are three  different elements inside the array.</li>
            <br>
            <li>Each element inside the array is a different data type.</li>
        </ul>

        <p>We can also save an array to a variable. You may have noticed we did this in the previous chapter.</p>

        <h2>Accessing ELements</h2>

        <p>Each element in an array has a numbered position known as its <i>index</i>. We can access individual items using ther index, which is similar to referencing an item in a list based on the item's position.</p>

        <p>Arrays in JavaScript are <i>Zero-indexed</i>, meaning the positions start counting from <span id="code">0</span> rather then <span id="code">1</span>. Therefore, the first item in an array will be position <span id="code">0</span> Let's see how we could access an element in an array:</p>

        <img src="/Portfolio/Project_1/Images/array indices.svg" title="An Array index example" alt="An image of an array indice example." class="imgcenter">

        <p>In the code snippet above:</p>

        <ul>
            <li><span id="code">cities</span> is an array that has three elements.</li>
            <br>
            <li>We're using bracket notation, <span id="code">[ ]</span> with the index after the name of the array to access the element.</li>
            <br>
            <li><span id="code">cities[0]</span> will access the element at index <span id="code">0</span> in the array <span id="code">cities</span>. You can think of <span id="code">cities[0]</span> as accessing the space in memory that holds he string/text <span id="code">New York</span>.</li>
        </ul>

        <p>You can also access indivdual characters in a string using bracket notation and the index. For instance, you can write:</p>

        <pre>
        <code>
            const hello = 'Hello World';
            console.log(hello[6]);
            // Output: W
        </code>
        </pre>

        <p>The console will display <span id="code">W</span> since it is the character that is at index <span id="code">6</span>.</p>

        <h2>Update Elements</h2>

        <p>In the previous exercise, you learned how to access elements inside an array or a string by using an index. Once you have access to an element in an array, you can update its value.</p>

        <pre>
        <code>
            let seasons = ['Winter', 'Spring', 'Summer', 'Fall'];

            seasons[3] = 'Autumn';
            console.log(seasons); 
            //Output: ['Winter', 'Spring', 'Summer', 'Autumn']
        </code>
        </pre>

        <p>In the example above, the <span id="code">seasons</span> array contained the names of the four seasons.</p>

        <p>However, we decided that we preferred to say <span id="code">Autumn</span> instead of <span id="code">Fall</span>.</p>

        <p>The line, <span id="code">seasons[3] = 'Autumn';</span> tells our program to change the item at index 3 of the <span id="code">seasons</span> array to be <span id="code">Autumn</span> instead of what is already there.</p>

        <h2>Arrays with let and const</h2>

        <p>You may recall that you can declare variables with both the <span id="code">let</span> and <span id="code">const</span> keywords. Variables declared with <span id="code">let</span> can be reassigned.</p>

        <p>Variables declared with the <span id="code"> const</span> keyword cannot be reassigned. However, elements in an array declared with <span id="code">const</span> remain mutable. Meaning that we can change the contents of a <span id="code">const</span> array, but cannot reassign a new array or a different value.</p>

        <h2>The .length property</h2>

        <p>One of an array's built-in properties is <span id="code">length</span> and it returns the number of items in the array. We access the <span id="code">.length</span> property just like we do with strings.</p>

        <p>Check the example below:</p>

        <pre>
        <code>
            const newYearsResolutions = ['Keep a journal', 'Take a falconry class'];

            console.log(newYearsResolutions.length);
            // Output: 2
        </code>
        </pre>

        <p>In the example above, we log <span id="code">newYearsResolutions.length</span> to the console using the following steps:</p>

        <ul>
            <li>We use <i>dot notation</i>, chaining a period with the property name to the array, to access the <span id="code">length</span> property of the <span id="code">newYearsResolutions</span> array.</li>
            <br>
            <li>Then we log the <span id="code">length</span> of <span id="code">newYearsResolutions</span> to the console.</li>
            <br>
            <li>Since <span id="code">newYearsResolutions</span> has two elements, <span id="code">2</span> would be logged to the console.</li>
        </ul>

        <p>When we want to know how many elements are in an array, we can access the <span id="code">.length</span>property.</p>

        <h2>The .push() Method</h2>

        <p>Let's learn about some built-in JavaScript methods that make working with arrays easier. These methods are specifically called on arrays to make common taks, like adding and removing elements, more straightforward.</p>

        <p>One method, <span id="code">.push()</span>, allows us to add items to the end of an array. Here is an example of how this is used:</p>

        <pre>
        <code>
            const itemTracker = ['item 0', 'item 1', 'item 2'];

            itemTracker.push('item 3', 'item 4');

            console.log(itemTracker); 
            // Output: ['item 0', 'item 1', 'item 2', 'item 3', 'item 4'];
        </code>
        </pre>

        <p>So,how does <span id="code">.push()</span> work?</p>

        <ol>
            <li>We access the <span id="code">push</span> method  by using dot notation, connecting <span id="code">push</span> to <span id="code">itemTracker</span> with a period.</li>
            <br>
            <li>Then we call it like a function. That's because <span id="code">.push()</span> is a function and one that JavaScript allows us to use right on an array.</li>
            <br>
            <li><span id="code">.push()</span> can take a single argument or multiple arguments separated by commas. In this case, we're adding two elements: <span id="code">item 3</span> and <span id="code">item 4</span> to <span id="code">itemTracker</span>.</li>
            <br>
            <li>Notice that <span id="code">.push()</span> changes, or <i>mutates</i>, <span id="code">itemTracker</span>. You might also see <span id="code">.push()</span> is the method for you!</li>
        </ol>

        <p>If you're looking for a method that will mutate an array by ading elements to it, then <span id="code">.push()</span> is the method for you!</p>

        <h2>The .pop() Method</h2>

        <p>Another array method, <span id="code">.pop()</span>, removes the last item of an array.</p>

        <pre>
        <code>
            const newItemTracker = ['item 0', 'item 1', 'item 2'];

            const removed = newItemTracker.pop();

            console.log(newItemTracker); 
            // Output: [ 'item 0', 'item 1' ]
            console.log(removed);
            // Output: item 2
        </code>
        </pre>

        <ul>
            <li>In the example above, calling <span id="code">.pop()</span> on the <span id="code">newItemTrracker</span> array removed <span id="code">item 2</span> from the end.</li>
            <br>
            <li><span id="code">.pop()</span> does not take any arguments, it simply removes the last element. In the example, we store the returned value in a variable <span id="code">removed</span> to be used for later.</li>
            <br>
            <li><span id="code">.pop()</span> is a method that mutates the initial array.</li>
        </ul>

        <p>When you need to mutate an array by removing the last element, use <span id="code">.pop()</span>.</p>

        <h2>More Array Methods</h2>

        <p>There are many more array methods than just <span id="code">.push()</span> and <span id="code">.pop()</span>. You can read about these array methods on the Docs entry for <a target="_blank" href="https://www.codecademy.com/resources/docs/javascript/arrays">JavaScript Arrays</a> </p>

        <p><span id="code">.pop()</span> and <span id="code">.push()</span> mutate the array on which they're called. However, there are times that we don't want to mutate the original array and we can use non-mutating arrays methods. Be sure to check the Docs to undersatnd the behavior of the method you are using.</p>

        <p>Some arrays methods that are available to JavaScript developers include: <span id="code">.join()</span>, <span id="code">.slice()</span>, <span id="code">.shift()</span>, <span id="code">.unshift()</span>, and <span id="code">.concat()</span> amongst many others. Using these built-in methods makes it easier to do some common tasks when working with arrays.</p>

    <h2>Arrays And Functions</h2>
    
    <p>In the previous chapters we went over arrays being mutable, or changeable. Well what happens if we try to changed an array inside a function? Does the array keep the change after the function call or is it scoped to inside the function.</p>

    <p>Take a look at the following example below. We call <span id="code">.push()</span> on an array inside a function. Recall, the <span id="code">.push()</span> method mutates, or changes, an array:</p>

    <pre>
    <code>
        const flowers = ['peony', 'daffodil', 'marigold'];

        function addFlower(arr) {
          arr.push('lily');
        }

        addFlower(flowers);

        console.log(flowers); // Output: ['peony', 'daffodil', 'marigold', 'lily']
    </code>
    </pre>

    <p>Let's go over what happened in the example:</p>

    <ul>
        <li>The <span id="code">flowers</span> array has 3 elements.</li>
        <br>
        <li>The function <span id="code">addFlower()</span> has a parameter of <span id="code">arr</span> uses <span id="code">.push()</span> to add a <span id="code">lily</span> element into <span id="code">arr</span></li>
        <br>
        <li>We call <span id="code">addFlower()</span> with an argument of <span id="code">flowers</span> which will execute the code inside the <span id="code">addFlower</span>.</li>
        <br>
        <li>We check the value of <span id="code">flowers</span> and it now includes the <span id="code">lily</span> element! The array was mutated!</li>
    </ul>

    <p>So when you pass an arrray into a function, if the array is mutated inside the function, that change will be maintained outside the function as well. You might also see this concept explained as <i>pass-by-reference</i> since what we are actually passing to the function is a reference to where the variable memory is stored and changing the memory.</p>

    <h2>Nested Arrays</h2>

    <p>Earlier we mentioned that arrays can store other arrays. When an array contains another array it is known as a <i>nested array</i>. Examine the example below:</p>

    <pre>
    <code>
        const nestedArr = [[1], [2, 3]];
    </code>
    </pre>

    <p>To access the nested arrays we can use bracket notation with the index value, just like we did to access any other element.</p>

    <pre>
    <code>
        const nestedArr = [[1], [2, 3]];

        console.log(nestedArr[1]); //Output: [2,3]
    </code>
    </pre>

    <p>Notice that <span id="code">nestedArr[1]</span> will grab the element in index 1 which is the array <span id="code">[2,3]</span>. Then, if we wanted to access the elements within the nested array we can <i>chain</i>, or add on, more bracket notation with index values.</p>

    <pre>
    <code>
        const nestedArr = [[1], [2, 3]];

        console.log(nestedArr[1]); // Output: [2, 3]
        console.log(nestedArr[1][0]); //Output 2
    </code>
    </pre>

    <p>In he secound <span id="code">console.log()</span> statement, we have two bracket notations chained to <span id="code">nestedArr[1][0]</span> and we get the value of <span id="code">2</span>.</p>

    <h1>Loops</h1>

    <p>A <i>loop</i> is a programming tool that repeats a set of instructions until a specified condition, called a <i>stopping condition</i> is reached. As a programmer, you'll find that you rely on loops all the time! You'll hear the generic term <i>iterate</i> when referring to loops; iterate simply means "to repeat".</p>

    <p>When we need to reuse a task in our code, we often bundle that action in a function. Similarly, when we see that a process has to repeat multiple times in a row, we write a loop. Loops allow us to create efficient code that automates processes to make scable, manageable programs.</p>

    <img src="/Portfolio/Project_1/Images/loops_abatraction_v5.svg" title="An example of loops" alt="An example of a javascript loop" class="imgcenter">

    <p>As illustrated in the diagram, loops iterate or repeat an action until a specific condition is met. When the condition is met, the loop stops and the computer moves on to the next part of the program.</p>

    <p>Before we delve into loops lets take a moment to develop an appreciation for loops. The best way to do that is by showing you how cumbersome it would be if a repeated task required you to type out the same code every single time.</p>

    <pre>
    <code>
        const vacationSpots = ['Finland', 'Iceland', 'Norway'];

        console.log(vacationSpots[0]); //Output Finland
        console.log(vacationSpots[1]); //Output Iceland
        console.log(vacationSpots[2]); //Output Norway     
    </code>
    </pre>

    <p>As we don't know loops yet we have to console log each element in the array separetely. Now doing it for just 3 vaction spots is fine but what if we had 100 places. Console logging each vaction spot by hand would be a tedious task! So how do we make this task easier?</p>

    <h2>The For Loop</h2>

    <p>Instead of writing out the same code over and over, loops allow us to tell computers to repeat a given block of code on its own. One way to give computers these instructions is with a <span id="code">for</span> loop.</p>

    <p>The typical <span id="code">for</span> loop includes an <i>iterator variable</i> that usually appears in all three expressions. The iterator variable is initialized, checked against the stopping condition, and assigned a new value on each lop iteration. Iterator variables can have any name, but it's best practice to use a descriptive variable name.</p>

    <p>A <span id="code">for</span> loop contains three expressions separated by <span id="code">;</span> inside the parentheses:</p>

    <ol>
        <li>An <i>initialization</i> starts the loop and can also be used to declare the iterator variable.</li>
        <br>
        <li>A <i>stopping condition</i> is the condition that the iterator variable is evaluated against- if the condition evaluates to <span id="code">true</span> the code block will run, and if it evaluates to false the code will stop.</li>
        <br>
        <li>An <i>iteration statement</i> is used to update the iterator variable on each loop.</li>
    </ol>

    <p>This can be confussing at first with all stopping conditions and iterators however with a bit of practice this becomes really easy and can save you 100's of hours.</p>

    <p>Let's take alook at an example:</p>

    <pre>
    <code>
        for (let counter = 0; counter < 4; counter++) {
            console.log(counter);
        }
    </code>
    </pre>

    <p>In this example, the output would be the following:</p>

    <pre>
    <code>
        //Output
        0
        1
        2
        3
    </code>    
    </pre>

    <p>Let's break down the example:</p>

    <ul>
        <li>The <i>initialization</i> is <span id="code">let counter = 0</span>, so the loop will start counting at <span id="code">0</span></li>
        <br>
        <li>The <i>stopping condition</i> is <span id="code">counter < 4</span>, meaning the loop will run as long as the iterator variable, <span id="code">counter</span>, is less than 4.</li>
        <br>
        <li>The iteration statement is <span id="code">counter++</span>. This means after each loop, the value of <span id="code">counter</span> will increase by 1. For the first iteration <span id="code">counter</span> will equal <span id="code">0</span>, for the second iteration <span id="code">counter</span> will equal 1, and so on.</li>
        <br>
        <li>The code block is inside of the curly braces, <span id="code">consle.log(counter)</span>, will execute until the condition evaluates to <span id="code">false</span>. The condition will be false when <span id="code">counter</span> is greater than or equal to 4 - the point that the condition becomes false is sometimes called the <i>stop condition</i>.</li>
    </ul>

    <p>This <span id="code">for</span> loop makes it possible to write <span id="code">0</span>, <span id="code">1</span>, <span id="code">2</span>, <span id="code">3</span> programmatically.</p>

    <h2>Looping In Reverse</h2>

    <p>What if we want the <span id="code">for</span> loop to log <span id="code">3</span>, <span id="code">2</span>, <span id="code">1</span>, and then <span id="code">0</span>? With simple modifications to the expressions, we can make our loop run backwards!</p>

    <p>To run a backward <span id="code">for</span> loop, we must:</p>

    <ul>
        <li>Set the iterator variable to the highest desired value in the initialization expression.</li>
        <br>
        <li>Set the stopping condition for when the iterator variable is less than the desired amount.</li>
        <br>
        <li>The iterator should decrease in intervals after each iteation.</li>
    </ul>

    <p>Using the same example lets make the for loop go bakwards.</p>

    <pre>
    <code>
        for (let counter = 3; counter >= 0; counter--){
            console.log(counter);
          }

          //Output 3, 2, 1, 0

    </code>
    </pre>

    <h2>Looping Through Arrays </h2>

    <p><span id="code">for</span> loops are very handy for iterating over data structures. For example, we can use a <span id="code">for</span> loop to perform the same operation on each element on an array. Arrays hold lists of data, like customer names or product information. Imagine we owned a store and wanted to increase the price of every product in our catalog. That could be a lot of repeating code, but by using a <span id="code">for</span> loop to iterate through the array we could accomplish this task easily.</p>

    <p>To loop through each element in an array, a <span id="code">for</span> loop should use the array's .length property in its condition.</p>

    <p>Lets take a look at the example below to see how <span id="code">for</span> loops iterate on arrays:</p>

    <pre>
    <code>
        const animals = ['Grizzly Bear', 'Sloth', 'Sea Lion'];
        for (let i = 0; i < animals.length; i++){
            console.log(animals[i]);
        }

        //Outputs 
        Grizzly Bear
        Sloth
        Sea Lion
    </code>
    </pre>

    <p>In the loop above, we've named our iterator variable <span id="code">i</span>. This is a variable naming convention you'll see in a lot of loops When we use <span id="code">i</span> to iterate through arrays we can think of it as being short-hand for the word index. Notice how our stopping condition checks that <span id="code">i</span> is less than <span id="code">animals.length</span>. Rememeber that arrays are zero-indexed, the index of the last element of an array is equivalent to the length of that array minus 1. If we tried to access an element at the index of <span id="code">animals.length</span> we will have gone too far!</p>

    <p>With <span id="code">for</span> loops, it's easier for us to work elements in arrays.</p>

    <h2>Nested Loops</h2>

    <p>When we have a loop running inside another loop, we call that a <i>nested loop</i>. One use for a nested <span id="code">for</span> loop is to compare the elements in two arrays. For each round of the outer <span id="code">for</span> loop, the inner <span id="code">for</span> loop will run completely.</p>

    <p>Let's look at an example of a nested loop:</p>

    <pre>
    <code>
    const myArray = [6, 19, 20];
    const yourArray = [19, 81, 2];
    for (let i = 0; i < myArray.length; i++) {
        for (let j = 0; j < yourArray.length; j++) {
            if (myArray[i] === yourArray[j]) {
                console.log('Both arrays have the number: ' + yourArray[j]);
            }
        }
    }
    </code>
    </pre>

    <p>Let's think about what's happening in the nested loop in our example. For each element in the outer loop array, <span id="code">myArray</span>, the inner loop will run in its entirety comparing the current element in the inner array, <span id="code">yourArray[j]</span>. When it finds a match, it prints a string to the console. So our output for this example would be 'Both arrays have the number: 19' Personally I had some trouble learning this as at first it seems very complicated I urge you to learn this and practice as much as possible with nested loops, after sometime it becomes very simple.</p>

    <h2>The While Loop</h2>

    <p>You're doing great getting this far, thank you for going through this with me. Now we are going to learn about a different type of loop: the while loop. To start, let's convert a <span id="code">for</span> loop into a <span id="code">while</span> loop to help understand how this works personally I fine if you have practiced for loops, while loops are less complicated. Anyways let's take a look:</p>

    <pre>
    <code>
        // A for loop that prints 1, 2, and 3
        for (let counterOne = 1; counterOne < 4; counterOne++){
            console.log(counterOne);
        }

        // A while loop that prints 1, 2, and 3
        let counterTwo = 1;
        while (counterTwo < 4) {
            console.log(counterTwo);
            counterTwo++;
        }

    </code>
    </pre>

    <p>Let's break down what's happening with our <span id="code">while</span> loop syntax:</p>

    <ul>
        <li>The <span id="code">counterTwo</span> variable is declared before the loop. We can access it inside our <span id="code">while</span> loop since it's in the global scope.</li>
        <br>
        <li>We start our loop with the keyword <span id="code">while</span> followed by our stopping condition, or <i>test condition</i>. This will be evaluated before each round of the loop. While the condition evaluates to <span id="code">true</span>, the block will continue to run. Once it evaluates to <span id="code">false</span> the loop will stop.</li>
        <br>
        <li>Next, we have our loop's code block which prints <span id="code">counterTwo</span> to the console and increments <span id="code">counterTwo</span></li>
    </ul>

    <p>What would happen if we didn't increment <span id="code">counterTwo</span> inside our block? If we didn't include this, <span id="code">counterTwo</span> would always have its initial value, <span id="code">1</span>. That would mean the testing condition <span id="code">counterTwo < 4</span> would always evaluate to <span id="code">true</span> and our loop would never stop running! This is called an <i>infinite loop</i> and it's something we always want to <b>avoid</b>. Infinite loops can take up all of your computer's processing power potentially freezing your computer.</p>

    <p>So you may be wondering when to use a <span id="code">while</span> loop! The syntax of a <span id="code">while</span> loop is ideal when we don't know in advance how many times a loop should run. Think of eating like a <span id="code">while</span> loop: When you start taking bites, you don't know the exact number you'll need to become full. Rather you'll eat <span id="code">while</span> you're hungry. In situations when we want a loop to execute an undertermined number of times, <span id="code">while</span> loops are the best choice.</p>

    <h2>Do While Statements</h2>

    <p>In some cases, you want a piece of code to run at least once and then loop based on a specific condition after its initial run. This is where the <span id="code">do...while</span> statement comes in.</p>

    <p>A <span id="code">do...while</span> statement says to do a task once and then keep doing it until a specified condition is no longer met. The syntax for a <span id="code">do..while</span> statement looks like this:</p>

    <pre>
    <code>
        let countString = '';
        let i = 0;

        do {
            countString = countString + i;
            i++;
        } while (i < 5);

        console.log(countString);
    </code>
    </pre>

    <p>In this example, the code block makes changes to the <span id="code">countString</span> variable by appending the string form of the <span id="code">i</span> variable to it. First, the code block after the <span id="code">do</span> keyword is executed once. Then the condition is evaluated. If the condition evaluates to <span id="code">true</span>, the block will execute again. The looping stops when the condition evaluates to <span id="code">false</span>.</p>

    <p>Note that the <span id="code">while</span> and <span id="code">do...while</span> loop are different! Unlike the <span id="code">while</span> loop, <span id="code">do...while</span> will run at least once whether or not the condition evaluates to <span id="code">true</span>.</p>

    <pre>
    <code>
        const firstMessage = 'I will print!';
        const secondMessage = 'I will not print!'; 

        // A do while with a stopping condition that evaluates to false
        do {
            console.log(firstMessage)
        } while (true === false);

        // A while loop with a stopping condition that evaluates to false
        while (true === false){
            console.log(secondMessage)
        };
    </code>
    </pre>

    <h2>The Break Keyword</h2>

    <p>Imagine we're looking to adopt a dog. We plan to go to the shelter every day for a year and then give up. But what if we meet our dream dog on day 65? We don't want to keep going to the shelter for the next 300 days just because our original plan was to go for a whole year. In our code, when we want to stop a loop from continuing to execute even though the original stopping condition we wrote for our loop hasn't been met, we can use the keyword <span id="code">break</span>.</p>

    <p>The <span id="code">break</span> keyword allows programs to 'break' out of the loop from within the loop's block.</p>

    <p>Let's check out the syntax of a <span id="code">break</span> keyword:</p>

    <pre>
    <code>
        for (let i = 0; i < 99; i++) {
            if (i > 2 ) {
               break;
            }
            console.log('Banana.');
        }
          
        console.log('Orange you glad I broke out the loop!');
    </code>
    </pre>
    
    <p>This is the output for the code above:</p>

    <pre>
    <code>
        Banana.
        Banana.
        Banana.
        Orange you glad I broke out the loop!
    </code>
    </pre>

    <p><span id="code">break</span> statements can be especially helpful when we're looping through large data structures! With breaks, we can add test conditions besides the stopping condition, and exit the loop when they're met.</p>

    <h1>High-Order Functions</h1>

    <p>We are often unaware of the number of assumptions we make when communicating in our native languages. If we told you to count to three, we would expect you say the numbers one, two, three. We assumed you would know to start with one and end with three. With programming, we need to be more explicit with our directions to the computer. Here's how we might tell the computer to count to three.</p>

    <pre>
    <code>
        for (let i = 1; 1 <= 3; i++) {
            console.log(i);
        }
    </code>
    </pre>

    <p>When we speak to other humans, we share a vocabulary that provides quick ways to communicate complicated concepts. When we say the word 'bake', it calls to mind a familiar subroutine-preheating an oven, putting something into an oven for a set amount of time, and finally removing it. This allows us to <i>abstract</i> away a lot of the details and communicate key concepts more concisely. Instead of listing all those details, we can say, 'We baked a cake,' and still impart all that meaning to you.</p>

    <p>In this chapter we'll learn how to use 'abstraction' in programming by writing functions. In addition to allowing us to reuse our code, functions help to make clear, readable programs. If you encounter <span id="code">countToThree()</span> in a program, you might be able to quickly guess what the function does without having to stop and read the function's body.</p>

    <p>We're also going to learn about a way to add another level of abstraction to our programming: <i>higher-order functions. Higher-order functions</i> are functions that accept other functions as arguments and/or return functions as output. This enables us to build abstractions on other abstractions, just like "We hosted a birthday party" is an abstraction that may build on the abstraction "We made a cake."</p>

    <h2>Functions As Data</h2>

    <p>JavaScirpt functions behave like any other data type in the language; we can assign functions to variables, and we an reassign them to new variables.</p>

    <p>Below, we have an annoyingly long function name that hurts the readability of any code in which it's used. Note: If the below function's syntax feels unfamiliar, revisit the arrows functions execrise to refresh your knowledge on ES6 arrow notation.</p>

    <pre>
    <code>
        const announceThatIAmDoingImportantWork = () => {
            console.log("I'm doing very important work!");
        };
    </code>
    </pre>

    <p>Let's pretend this function does important work and needs to be called repeatedly. To rename this function without sacrificing the source code, we can re-assign the function to a variable with a suitably short name:</p>

    <pre>
    <code>
        const busy = announceThatIAmDoingImportantWork;

        busy(); // This function call barely takes any space!
    </code>
    </pre>

    <p><span id="code">busy</span> is a variable that holds a <i>reference</i> to our original function. If we could look up the address in memory of <span id="code">busy</span> and the address in memory of <span id="code">announceThatIAmDoingImportantWork</span> they would point to the same place. Our new <span id="code">busy()</span> function can be invoked with parentheses as if that was the name we originally gave our function.</p>

    <p>Notice how we assign <span id="code">announceThatIAmDoingImportantWork</span> without parentheses as the value to the <span id="code">busy</span> variable. We want to assign the value of the function itself, not the value it returns when invoked.</p>

    <p>In JavaScirpt, functions are <i>first class objects</i>. This means that, like other objects you've encountered, JavaScirpt functions can have properties and methods.</p>

    <p>Since functions are a type of object, they have properties such as <span id="code">.length</span> and <span id="code">.name</span>, and methods such as <span id="code">.toString()</span>. You can see more about methods and properties of functions in the Docs. Here you can find a link to the method <span id="code">.toString()</span>. You'll notice I am a contributor to the codecademy docs for the method <span id="code">.toString()</span> <a target="_blank" href="https://www.codecademy.com/resources/docs/javascript/strings/toString">Docs</a></p>

    <p>Functions are special because we can invoke them, but we can still treat them like any other type of data.</p>

    <h2>Functions As Parameters</h2>

    <p>As you know, a parameter is a placeholder for the data that gets passed into a function. Since functions can behave like any other type of data in JavaScript, it might not surprise you to learn that functions can accept other functions as parameters. A <i>higher-order function</i> is a function that either accepts functions as parameters, returns a function, or both! We call functions that get passed in as parameters <i>callback functions</i>. Callback functions get invoked during the execution of the higher-order function.</p>

    <p>When we invoke a higher-order function, and pass another function in as an argument, we don't invoke the argument function. Invoking it would evaluate to passing in the return value of that function call. With callback functions, we pass in the function itself by typing the function name <i>without</i> the parentheses:</p>

    <pre>
    <code>
        const higherOrderFunc = param => {
            param();
            return `I just invoked ${param.name} as a callback function!`
        }
           
        const anotherFunc = () => {
            return 'I\'m being invoked by the higher-order function!';
        }
          
        higherOrderFunc(anotherFunc);
    </code>
    </pre>

    <p>We wrote a higher-order function <span id="code">higherOrderFunc</span> that accepts a single parameter, <span id="code">param</span>. Inside the body, <span id="code">param</span> gets invoked using parentheses. And finally, a string is returned, telling us the name of the callback function that was passed in.</p>

    <p>Below the higher-order function, we have another function aptly named <span id="code">anotherFunc.This function aspires to be called inside the higher-order function.</span></p>

    <p>Lastly, we invoke <span id="code">higherOrderFunc()</span>, passing in <span id="code">anotherFunc</span> as its argument, thus fulfilling its dreams of being called by the higher-order function.</p>

    <pre>
    <code>
        higherOrderFunc(() => {
            for (let i = 0; i <= 10; i++){
              console.log(i);
            }
        });
    </code>
    </pre>

    <p>In this example, we invoked <span id="code">higherOrderFunc()</span> with an anonymous function (a function without a name) that counts to 10. Anonymous functions can be arguments too!</p>

    <p>Great job! By thinking about functions as data, and learning about higher-order functions, you've taken important steps in learning to write clean, modular code that takes advantage of JavaScript's flexibility.</p>

    <h1>Iterators</h1>

    <p>Imagine you had a grocery list and you wanted to know what each item on the list was. You'd have to scan through each row and check for the item. This common task is similar to what we have to do when we want to iterate over, or loop through, an array. One tool at our disposal is the <span id="code">for</span> loop. However, we also have access to built-in array methods which make looping easier.</p>

    <p>The built-in JavaScript array methods that help us iterate are called <i>iteration methods</i>, at times referred to as iterators. Iterators are methods called on arrays to manipulate elements and return values. In this chapter you will learn the syntac for these methods, their reutrn values, how to use the documentation to understand them, and how to choose the right iterator method for a given task.</p>

    <h2>The .forEach() Method</h2>

    <p>The first iteration method that we're going to learn is <span id="code">.forEach()</span>. Aptly named, <span id="code">.forEach()</span> will execute the same code for each element of an array.</p>

    <img src="/Portfolio/Project_1/Images/iterator anatomy.svg" title="Iterator Anatomy" alt="An image of iteration anatomy" class="imgcenter">

    <p>The code above will log a nicely formatted list of the groceries to the console. Let's explore the syntax of invoking <span id="code">.forEach()</span></p>

    <ul>
        <li><span id="code">groceries.forEach()</span> calls the <span id="code">forEach</span> method on the <span id="code">groceries</span> array.</li>
        <br>
        <li><span id="code">.forEach()</span> takes an argument of callback funciton. Remember, a callback function is a function passed as an argument into another function.</li>
        <br>
        <li><span id="code">.forEach()</span> loops through the array and executes the callback function for each element. During each executing, the current element is passed as an argument to the callback function.</li>
        <br>
        <li>The return vallue for <span id="code">.forEach()</span> will always be <span id="code">underfined</span>.</li>
    </ul>

    <p>Another way to pass a callback for <span id="code">.forEach()</span> is to use arrow function syntax.</p>

    <pre>
    <code>
        groceries.forEach(groceryItem => console.log(groceryItem));
    </code>
    </pre>

    <p>We can also define a function beforehand to be used as the callback function.</p>

    <pre>
    <code>
        function printGrocery(element){
            console.log(element);
        }
          
        groceries.forEach(printGrocery);
    </code>
    </pre>

    <p>The above example uses a function declaration but you can also use a function expression or arrow function as well.</p>

    <p>All three code snippets do the same thing. In each array iteration method, we can use any of the three examples to supply a callback function as an argument to the iterator. It's good to be aware of the diferent ways to pass in callback functions as arguments in iterators because developers have different stylistic preferences. Nonetheless, due to the strong adoption of ES6, we will be using arrow function syntax in the later exercises.</p>

    <h2>The .map() Method</h2>

    <p>The second iterator we're going to cover is <span id="code">.map()</span>. When <span id="code">.map()</span> is called on an array, it takes an argument of a callback function and returns a new array! Take a look at an example of calling <span id="code">.map()</span>:</p>

    <pre>
    <code>
        const numbers = [1, 2, 3, 4, 5]; 

        const bigNumbers = numbers.map(number => {
            return number * 10;
        });
    </code>
    </pre>

    <p><span id="code">.map()</span> works in a similar manner to <span id="code">.forEach()</span>- the major difference is that <span id="code">.map()</span> returns a new array.</p>

    <p>In the example above:</p>

    <ul>
        <li><span id="code">numbers</span> is an array of numbers.</li>
        <br>
        <li><span id="code">bigNumbers</span> will store the return value of calling <span id="code">.map()</span> on <span id="code">numbers</span>.</li>
        <br>
        <li><span id="code">numbers.map</span> will iterate through each element in the <span id="code">numbers</span> array and pass the element into the callback function.</li>
        <br>
        <li><span id="code">return number * 10</span> is the code we wish to execute upon each element in the array. This will saave each value from the <span id="code">numbers</span> array, multiplied by <span id="code">10</span>, to a new array.</li>
    </ul>

    <p>If we take a look at <span id="code">numbers</span> and <span id="code">bigNumbers</span>:</p>

    <pre>
    <code>
        console.log(numbers); // Output: [1, 2, 3, 4, 5]
        console.log(bigNumbers); // Output: [10, 20, 30, 40, 50]
    </code>
    </pre>

    <p>Notice that the elements in <span id="code">numbers</span> were not altered and <span id="code">bigNumbers</span> is a new array.</p>

    <h2>The .filter() Method</h2>

    <p>Another useful iterator method is <span id="code">.filter()</span>. Like <span id="code">.map()</span>, <span id="code">.filter()</span> returns a new array. However, <span id="code">.filter()</span> returns an array of elements after filtering out certain elements from the original array. The callback function for the <span id="code">.filter()</span> method should return <span id="code">true</span> or <span id="code">false</span> depending on the element that is passed to it. The elements that cause the callback function to return <span id="code">true</span> are added to the new array. Take a look at the following example:</p>

    <pre>
    <code>
        const words = ['chair', 'music', 'pillow', 'brick', 'pen', 'door']; 

        const shortWords = words.filter(word => {
            return word.length < 6;
        });
    </code>
    </pre>

    <ul>
        <li><span id="code">words</span> is an array that contains string elements.</li>
        <br>
        <li><span id="code">const shortWords = </span> declares a new variable that will store the returned array from invoking <span id="code">.filter()</span>.</li>
        <br>
        <li>The callback function is an arrow function that has a single parameter, <span id="code">word</span>. Each element in the <span id="code">words</span> array will be passed to this function as an argument.</li>
        <br>
        <li><span id="code">word.length < 6;</span> is the condition in the callback function. Any <span id="code">word</span> from the <span id="code">words</span> array that has a fewer then <span id="code">6</span> characters will be addedto the <span id="code">shortWords</span> array.</li>
    </ul>

    <p>Let's also check the values of <span id="code">words</span> and <span id="code">shortWords</span>:</p>

    <pre>
    <code>
        console.log(words); // Output: ['chair', 'music', 'pillow', 'brick', 'pen', 'door']; 
        console.log(shortWords); // Output: ['chair', 'music', 'brick', 'pen', 'door']
    </code>
    </pre>
    
    <p>Observe how <span id="code">words</span> was not mutated, i.e. changed, and <span id="code">shortWords</span> is a new array.</p>

    <h2>The .findIndex() Method</h2>

    <p>We sometimes want to find the location of an element in an array. That's where the <span id="code">.findIndex()</span> method comes in! Calling <span id="code">.findIndex()</span> on an array will return the index of the first element that evaluates to <span id="code">true</span> in the callback function.</p>

    <pre>
    <code>
        const jumbledNums = [123, 25, 78, 5, 9]; 

        const lessThanTen = jumbledNums.findIndex(num => {
            return num < 10;
        });
    </code>
    </pre>

    <ul>
        <li><span id="code">jumbledNums</span> is an array that contains elements that are numbers.</li>
        <br>
        <li><span id="code">const lessThanTen =</span> declares a new variable that stores the returned index number from invoking <span id="code">.findIndex()</span>.</li>
        <br>
        <li>The callback function is an arrow function that has a single parameter, <span id="code">num</span>. Each element in the <span id="code">jumbledNums</span> array will be passed to this function as an argument.</li>
        <br>
        <li><span id="code">num < 10;</span> is the condition that elements are checked against. <span id="code">.findIndex()</span> will return the index of the first element which evaluates to <span id="code">true</span> for that condition.</li>
    </ul>

    <p>Let's take a look at what <span id="code">lessThanTen</span> evaluates to:</p>

    <pre>
    <code>
        console.log(lessThanTen); // Output: 3
    </code>
    </pre>

    <p>If we check what element has index of 3:</p>
    
    <pre>
    <code>
        console.log(jumbledNums[3]); // Output: 5
    </code>
    </pre>

    <p>Great, the element in index <span id="code">3</span> is the number <span id="code">5</span>. This makes sense since <span id="code">5</span> is the first element that is less than 10.</p>

    <p>If there isn't a single element in the array that satisfies the condition in the callback, then <span id="code">.findIndex()</span> will return <span id="code">-1</span>.</p>

    <pre>
    <code>
        const greaterThan1000 = jumbledNums.findIndex(num => {
            return num > 1000;
        });
          
        console.log(greaterThan1000); // Output: -1
    </code>
    </pre>

    <h2>The .reduce() Method</h2>

    <p>Another widely used iteration method is <span id="code">.reduce()</span>. The <span id="code">.reduce()</span> method returns a single value after iterating through the elements of an array, thereby <i>reducing</i> the array. Take a look at the example below:</p>

    <pre>
    <code>
        const numbers = [1, 2, 4, 10];

        const summedNums = numbers.reduce((accumulator, currentValue) => {
            return accumulator + currentValue
        })

        console.log(summedNums) // Output: 17
    </code>
    </pre>

    <p>Now let's go over the use of <span id="code">.reduce()</span> from the example above:</p>

    <ul>
        <li><span id="code">numbers</span> is an array that contains numbers.</li>
        <br>
        <li><span id="code">summedNums</span> is a variable that stores the returned value of invoking <span id="code">.reduce()</span> on <span id="code">numbers</span>.</li>
        <br>
        <li><span id="code">numbers.reduce()</span> calls the <span id="code">.reduce()</span> method on the <span id="code">numbers</span> array and takes in a callback function as argument.</li>
        <br>
        <li>The callback function has two parameters, <span id="code">accumulator</span> and <span id="code">currentValue</span>. The value of <span id="code">accumulator</span> starts off as the value of the first element in the array and the <span id="code">currentValue</span> starts as the second element. To see the value of <span id="code">accumulator</span> and <span id="code">currentValue</span> change.</li>
        <br>
        <li>As <span id="code">.reduce()</span> iterates through the array, the return value of the callback function becomes the <span id="code">accumulator</span> value for the next iteration, <span id="code">currentValue</span> takes on the value of the current element in the looping process.</li>
    </ul>

    <p>The <span id="code">.reduce()</span> method can also take an optional second parameter to set an initial value for <span id="code">accumulator</span> Remember, the first argument is the callback function! For instance:</p>

    <pre>
    <code>
        const numbers = [1, 2, 4, 10];

        const summedNums = numbers.reduce((accumulator, currentValue) => {
            return accumulator + currentValue
        }, 100)  // <- Second argument for .reduce()

        console.log(summedNums); // Output: 117
    </code>
    </pre>

    <h2>Iterator Documentation</h2>

    <p>There are many additional built-in array methods, a complete list of which is on the <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Iteration_methods">MDN's Array iteration methods page</a>.</p>

    <p>The documentation for each method contains several sections:</p>

    <ol>
        <li>A short definition.</li>
        <br>
        <li>A block with the correct syntax for using the method.</li>
        <br>
        <li>A list of parameters the method accepts or requires.</li>
        <br>
        <li>The return value of the function.</li>
        <br>
        <li>An extended description.</li>
        <br>
        <li>Examples of the method's use.</li>
        <br>
        <li>Other additional information</li>
    </ol>

    <h2>Choosing The Right Iterator</h2>

    <p>There are many iteration methods you can choose. In addition to learning the correct syntax for the use of iteration methods, it is also important to learn how to choose the correct method for different scenarios. This will make sure you produce clean code and not have to problem solve so much.I would suggest that if your not sure what method you need is to research and practice prehaps use github like I am so you can revert back to an old save if needs be.</p>

    <h1>Introduction To Objects</h1>

    <p>Its now time to learn more about the basic structure that permeates nearly every aspect of JavaScript programming:<a target="_blank" href="https://www.codecademy.com/resources/docs/javascript/objects">Objects</a>.</p>

    <p>You're probabably already more comfortable with objects than you think, because JavaScript loves objects! Many components of the language are actually objects under the hood, and even the parts that aren't - like strings or numbers - can still act like objects in some instances.</p>

    <img src="/Portfolio/Project_1/Images/javascript_objects_example.svg" class="imgcenter" title="An example of Objects" alt="An image of the basic structure of Objects">

    <p>There are only seven fundamental data types in JavaScirpt, and six of those are the primitive data types: string, number, boolean, null, undefined, and symbol. With the seventh type, objects, we open our code to more complex possibilities. We can use JavaScirpt objects to model real-world things, like a basketball, or we can use objects to build the data structures that make the web possible.</p>

    <p>At their core, JavaScirpt objects are containers storing related data and functionality, but that deceptively simple task is extremely powerful in practice. You've been using the power of objects all along, but now it's time to understand the mechanics of objects and start making your own!</p>

    <h2>Creating Object Literals</h2>

    <p>Objects can be assigned to variables just like any JavaScirpt type. We use curly braces, <span id="code">{ }</span>, to designate an object literal:</p>

    <pre>
    <code>
        let spaceship = {}; // Spaceship is an empty object
    </code>
    </pre>

    <p>We fill an object with unordered data. This data is organized into <i>key-value pairs</i>. A key iis like a variable name that points to a location in memory that holds value.</p>

    <img src="/Portfolio/Project_1/Images/key_value_example.svg" class="imgcenter" title="Key value example" alt="An image of a key value example">

    <p>A key's value can be of any data type in the language including functions or other objects.</p>

    <p>We make a key-value pair by writing the key's name, or <i>identifier</i>, followed by a colon and then the value. We seperate each key-value pair in an object literal with a comma <span id="code">,</span>. Keys are strings, but when we have a key that does not have any special characters in it, JavaScirpt allows us to omit or call the quotation marks:</p>

    <img src="/Portfolio/Project_1/Images/javascript_object_spaceship_example.svg" title="The spaceship object exmaple" alt="An image of an example of an object with spaceship" class="imgcenter">

    <pre>
    <code>
        // An object literal with two key-value pairs
        let spaceship = {
            'Fuel Type': 'diesel',
            color: 'silver'
        };
    </code>
    </pre>

    <p>The <span id="code">spaceship</span> object has two properties <span id="code">Fuel Type</span> and <span id="code">color</span>. <span id="code">'Fuel Type'</span> has quotation marks because it contains a space character.</p>

    <h2>Accessing Properties</h2>

    <p>There are two ways we can access an object's property. Let's exxplore the first way - dot notation.</p>

    <p>We have used dot notation to access the properties and methods of build-in objects and data instances:</p>

    <pre>
    <code>
        'hello'.length; //Returns 5
    </code>
    </pre>

    <p>With property fot notation, we write the object's name, followed by the dot operator ad then the property name (key):</p>

    <pre>
    <code>
        let spaceship = {
            homePlanet: 'Earth',
            color: 'silver'
        };
        spaceship.homePlanet; // Returns 'Earth',
        spaceship.color; //Returns 'silver',
    </code>
    </pre>

    <img src="/Portfolio/Project_1/Images/object dot notation example.svg" title="An example of dot notation with objects" alt="An image on dot notation" class="imgcenter">

    <p>If we try access a property that does not exist on that object, <span id="code">undefined</span> will be returned.</p>

    <pre>
    <code>
        spaceship.favoriteIcecream; // Returns undefined
    </code>
    </pre>

    <h2>Bracket Notation</h2>

    <p>The second way to access a key's value is by using bracket notation, <span id="code">[ ]</span>.</p>

    <p>We have used bracket notation when indexing an array:</p>

    <pre>
    <code>
        ['A', 'B', 'C'][0]; // Returns 'A'
    </code>
    </pre>

    <p>To use bracket notation to access an object's property, we pass in the property name (key) as a string.</p>

    <img src="/Portfolio/Project_1/Images/object access bracket.svg" title="An example of object access using bracket notation" alt="An image on bracket notation" class="imgcenter">

    <p>We <b>must</b> use bracket notation when accessing keys that have numbers, spaces, or special characters in them. Without bracket notation in these situations, our code would throw an error.</p>

    <pre>
    <code>
        let spaceship = {
            'Fuel Type': 'Turbo Fuel',
            'Active Duty': true,
            homePlanet: 'Earth',
            numCrew: 5
          };
          spaceship['Active Duty'];   // Returns true
          spaceship['Fuel Type'];   // Returns  'Turbo Fuel'
          spaceship['numCrew'];   // Returns 5
          spaceship['!!!!!!!!!!!!!!!'];   // Returns undefined
    </code>
    </pre>

    <p>With bracket notation you can also use a variable inside the brackets to select the keys of an object. This can be especially helpful when working with functions:</p>

    <pre>
    <code>
        let returnAnyProp = (objectName, propName) => 
        objectName[propName];
 
        returnAnyProp(spaceship, 'homePlanet'); 
        // Returns 'Earth'
    </code>
    </pre>

    <p>If we tried to write our <span id="code">returnAnyProp()</span> function with dot notation (<span id="code">objectName.propName</span>) the computer would look for a key of <span id="code">'propName'</span> on our object and not the value of the <span id="code">propName</span> parameter.</p>

    <h2>Property Assignment</h2>

    <p>Once we have defined an object, we're not stuck with all the properties we wrote. Objeccts are <i>mutable</i> meaning we can update them after we create them!</p>

    <p>We can use either dot notation, or bracket notation, and the assignment operator <span id="code">=</span> to add new key-value pairs to an object or change an existing property.</p>

    <img src="/Portfolio/Project_1/Images/object_property_assignment.svg" title="An example of an object property assignment" alt="An image on property assignment" class="imgcenter">

    <p>One of two things can happen with property assignment:</p>

    <ul>
        <li>If the property already exists on the object, whatever value it held before will be replaced with the newly assigned value.</li>
        <br>
        <li>If there was no property with that name, a new property will be added to the object.</li>
    </ul>

    <p>It's important to know that although we can't reassign an object declared with <span id="code">const</span>, we can still mutate it, meaning we can add new properties and change the properties that are there.</p>

    <pre>
    <code>
        const spaceship = {type: 'shuttle'};
        spaceship = {type: 'alien'}; 
        // TypeError: Assignment to constant variable.
        spaceship.type = 'alien'; 
        // Changes the value of the type property
        spaceship.speed = 'Mach 5'; 
        // Creates a new key of 'speed' with a value of 'Mach 5'
    </code>
    </pre>

    <p>You can delete a property from an object with the <span id="code">delete</span> operator.</p>

    <pre>
    <code>
        const spaceship = {
            'Fuel Type': 'Turbo Fuel',
            homePlanet: 'Earth',
            mission: 'Explore the universe' 
          };
           
          delete spaceship.mission;  
          // Removes the mission property
    </code>
    </pre>

    <h2>Methods</h2>

    <p>When the data stored on an object is a function we call that a method. A property is what an object has, while a method is what an object does.</p>

    <p>Do object methods seem familiar? That's because you've been using them all along! For exmaple <span id="code">console</span> is a global JavaScirpt object and <span id="code">.log()</span> is a method on that object. <span id="code">Math</span> is also a global JavaScirpt object and <span id="code">.floor()</span> is a method on it. We can include methods in our object literals by creating ordinary, colon-seperated key-value pairs. The key serves as our method's name, while the value is an anonymous function expression.</p>

    <pre>
    <code>
        const alienShip = {
            invade: function () { 
              console.log('Hello! We have come to dominate your planet. Instead of Earth, it shall be called New Xaculon.')
            }
        };
    </code>
    </pre>

    <p>With the new method syntax introduced in ES6 we can omit the colon and the <span id="code">function</span> keyword.</p>

    <pre>
    <code>
        const alienShip = {
            invade () { 
              console.log('Hello! We have come to dominate your planet. Instead of Earth, it shall be called New Xaculon.')
            }
        };
          
    </code>
    </pre>

    <p>Object methods are invoked by appending the obejct's name with the dot operator followed by the method name and parentheses:</p>

    <pre>
    <code>
        alienShip.invade(); 
        // Prints 'Hello! We have come to dominate your planet. Instead of Earth, it shall be called New Xaculon.'
    </code>
    </pre>

    <h2>Nested Objects</h2>

    <p>In application code, objects are often nested- an object might have another object as a property which in turn could have a property that's an array of even more objects!</p>

    <p>In our <span id="code">spaceship</span> object, we want a <span id="code">crew</span> object. This will contain all the crrew memebers who do important work on the craft. Each of those <span id="code">crew</span> memebers are objects themselves. They have propertues like <span id="code">name</span>, and <span id="code">degree</span>, and they each have unique methods based on their roles. We can also nest other objects in the <span id="code">spaceship</span> such as a <span id="code">telescope</span> or nest details about the spaceship's computers inside a parent <span id="code">nanoelectronics</span> object.</p>

    <pre>
    <code>
        const spaceship = {
            telescope: {
               yearBuilt: 2018,
               model: '91031-XLT',
               focalLength: 2032 
            },
           crew: {
               captain: { 
                   name: 'Sandra', 
                   degree: 'Computer Engineering', 
                   encourageTeam() { console.log('We got this!') } 
                }
           },
           engine: {
               model: 'Nimbus2000'
            },
            nanoelectronics: {
                computer: {
                   terabytes: 100,
                   monitors: 'HD'
                },
               'back-up': {
                  battery: 'Lithium',
                  terabytes: 50
                }
           }
       }; 
    </code>
    </pre>

    <p>We can chain operators to access nested properties. We'll have to pay attention to which operator makes sense to use in each layer. It can be helpful to pretend you are the computer and evaluate each expression from left to right so that each operation starts to feel a little more manageable.</p>

    <pre>
    <code>
        spaceship.nanoelectronics['back-up'].battery; 
        // Returns 'Lithium'
    </code>
    </pre>

    <p>In the code above:</p>

    <ul>
        <li>First the computer evaluates <span id="code">spaceship.nanoelectronics</span>, which resultsin an object containing the <span id="code">back-up</span> and <span id="code">computer</span> objects.</li>
        <br>
        <li>We accessed the <span id="code">back-up</span> object by appending <span id="code">['back-up']</span>.</li>
        <br>
        <li>The <span id="code">back-up</span> object has a <span id="code">battery</span> property, accessed with <span id="code">.battery</span> which returned the value stored there: <span id="code">'Lithium'</span>.</li>
    </ul>

    <h2>Pass By Reference</h2>

    <p>Objects are <i>passed by reference</i>. This means when we pass a variable assigned to an object into a function as an argument, the computer interprets the parameter name as pointing to the space in memory holding that object. As a result, functions which change object properties actually mutate the object permanently (even when the object is assigned to a <span id="code">const</span> variable)</p>

    <pre>
    <code>
        const spaceship = {
            homePlanet : 'Earth',
            color : 'silver'
        };
           
        let paintIt = obj => {
            obj.color = 'glorious gold'
        };
           
        paintIt(spaceship);
           
        spaceship.color 
        // Returns 'glorious gold'
    </code>
    </pre>

    <p>Our function <span id="code">paintIt()</span> permanently changed the color of our <span id="code">spaceship</span> object. However, reassignment of the <span id="code">spaceship</span> variable wouldn't work in the same way:</p>

    <pre>
    <code>
        let spaceship = {
            homePlanet : 'Earth',
            color : 'red'
        };
        let tryReassignment = obj => {
            obj = {
              identified : false, 
              'transport type' : 'flying'
            }
            console.log(obj) 
            // Prints {'identified': false, 'transport type': 'flying'}
           
        };
        tryReassignment(spaceship) 
        // The attempt at reassignment does not work.
        
        spaceship 
        // Still returns {homePlanet : 'Earth', color : 'red'};
           
        spaceship = {
            identified : false, 
            'transport type': 'flying'
        }; 
        // Regular reassignment still works.
    </code>
    </pre>

    <p>Let's look at what happened in the code example:</p>

    <ul>
        <li>We declared this <span id="code">spaceship</span> object with <span id="code">let</span>. This allowed us to reassign it to a new object with <span id="code">identified</span> and <span id="code">'transport type'</span> properties with no problems.</li>
        <br>
        <li>When we tried the same thing using a function designed to reassign the object passed into it, the reassignment didn't stick (even though calling <span id="code">console.log()</span> on the object produced the expected result).</li>
        <br>
        <li>When we passed <span id="code">spaceship</span> into that function, <span id="code">obj</span> became a reference to the memory location of the <span id="code">spaceship</span> variable. This is because the <span id="code">obj</span> parameter of the <span id="code">tryReassignment()</span> function is a variable in its own right. The body of <span id="code">tryReassignment()</span> has no knowledge of the <span id="code">spaceship</span> variable at all!</li>
        <br>
        <li>When we did the reassignment in the body of <span id="code">tryReassignment()</span>, the <span id="code">obj</span> variable came to refer to the memory location of the object <span id="code">{'identified' : false, 'transport type' : 'flying'}</span>, while the <span id="code">spaceship</span> variable was completely unchanged from its earlier value.</li>
    </ul>

    <h2>Looping Through Objects</h2>

    <p>Loops are programming tools that repeat a block of code until a condition is met. We learned how to iterate through arrays using their numerical indexing, but the key-value pairs in objects aren't ordered! JavaScirpt has given us an alternative solution for iterating through objects with the <span id="code">for...in</span> syntax. More information can be found <a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in">Here</a>!</p>

    <p><span id="code">for...in</span> will execute a given block of code for eac property in an object.</p>

    <pre>
    <code>
        let spaceship = {
            crew: {
              captain: { 
                name: 'Lily', 
                degree: 'Computer Engineering', 
                cheerTeam() { console.log('You got this!') } 
              },
              'chief officer': { 
                name: 'Dan', 
                degree: 'Aerospace Engineering', 
                agree() { console.log('I agree, captain!') } 
              },
              medic: { 
                name: 'Clementine', 
                degree: 'Physics', 
                announce() { console.log(`Jets on!`) } },
              translator: {
                name: 'Shauna', 
                degree: 'Conservation Science', 
                powerFuel() { console.log('The tank is full!') } 
              }
            }
        }; 
          
          // for...in
          for (let crewMember in spaceship.crew) {
            console.log(`${crewMember}: ${spaceship.crew[crewMember].name}`);
          }
    </code>
    </pre>
    
    <p>Our <span id="code">for...in</span> will iterate through each element of the <span id="code">spaceship.crew</span> object. In each iteration, the variable <span id="code">crewMember</span> is set to one of <span id="code">spaceship.crew</span>'s keys, enabling us to log a list of crew members' role and <span id="code">name</span>.</p>

    <h1>Advanced Objects</h1>

    <p>Remember, objects in JavaScirpt are containers tha store data and functionality. In this lesson, we will build upon the fundamentals of creating objects and explore some advanced concepts.</p>

    <p>In this chapter we will cover these topics:</p>

    <ul>
        <li>How to use the <span id="code">this</span> keyword.</li>
        <br>
        <li>Conveying privacy in JavaScirpt methods.</li>
        <br>
        <li>Defining getters and setters in objects.</li>
        <br>
        <li>Creating factory functions.</li>
        <br>
        <li>Finally, using destructuring techniques.</li>
    </ul>

    <h2>The <span id="code">this</span> Keyword</h2>

    <p>Objects are collections of related data and functionality. We store that functionality in methods on our objects.</p>

    <p>For example:</p>

    <pre>
    <code>
        const goat = {
            dietType: 'herbivore',
            makeSound() {
              console.log('baaa');
            }
        };
    </code>
    </pre>

    <p>In our <span id="code">goat</span> object we have a <span id="code">.makeSound()</span> method. We can invoke the <span id="code">.makeSound()</span> method on <span id="code">goat</span>.</p>

    <pre>
    <code>
        goat.makeSound();
        // Prints baaa
    </code>
    </pre>

    <p>Okay, we have a <span id="code">goat</span> object that can print <span id="code">baaa</span> to the console. Everything seems to be working fine. What if we wanted to add a new method to our <span id="code">goat</span> object called <span id="code">.diet()</span> that prints the <span id="code">goat</span>'s <span id="code">dietType</span>?</p>

    <pre>
    <code>
        const goat = {
            dietType: 'herbivore',
            makeSound() {
              console.log('baaa');
            },
            diet() {
              console.log(dietType);
            }
        };
        goat.diet(); 
        // Output will be "ReferenceError: dietType is not defined"
    </code>
    </pre>

    <p>That's weird, why is <span id="code">dietType</span> not defined even though it's a property of <span id="code">goat</span>? That's because inside the scope of the <span id="code">.diet()</span> method, we don't automatically have access to other properties of the <span id="code">goat</span> object.</p>

    <p>Here's where <span id="code">this</span> keyword comes to the rescue. If we change the <span id="code">.diet()</span> method to use the <span id="code">this</span>, the <span id="code">.diet()</span> works!:</p>

    <pre>
    <code>
        const goat = {
            dietType: 'herbivore',
            makeSound() {
              console.log('baaa');
            },
            diet() {
              console.log(this.dietType);
            }
        };
          
        goat.diet(); 
        // Output: herbivore
    </code>
    </pre>

    <p>The <span id="code">this</span> keyword references the <i>calling object</i> which provides access to the calling object's is <span id="code">goat</span> and by using <span id="code">this</span> we are accessing the <span id="code">goat</span> object itself, and then the <span id="code">dietType</span> property of <span id="code">goat</span> by using porperty dot notation.</p>

    <h2>Arrow Functions And <span id="code">this</span></h2>

    <p>In the previous chapter for a method, the calling object is the object the method belongs to. If we use the <span id="code">this</span> keyword in a method then the value of <span id="code">this</span> is the calling object. However, it becomes a bit more complicated when we start using arrow functions for methods. Lets take a look at the example below:</p>

    <pre>
    <code>
        const goat = {
            dietType: 'herbivore',
            makeSound() {
              console.log('baaa');
            },
            diet: () => {
              console.log(this.dietType);
            }
        };
          
        goat.diet(); 
        // Prints undefined
    </code>
    </pre>

    <p>In the comment, you can see that <span id="code">goat.diet()</span> would log <span id="code">undefined</span>. So what happened? Why? Well notice that the <span id="code">.diet()</span> method is defined using an arrow function.</p>

    <p>Arrow functions inherently <i>bind</i>, or tie, an already defined <span id="code">this</span> value to the function itself that is NOT the calling object. In the code snippet, the value of <span id="code">this</span> is the <i>global object</i>, or an object that ecists in the global scope, which doesn't have a <span id="code">dietType</span> property and therefore returns <span id="code">undefined</span>.</p>

    <p>The key takeaway from the example above is to <i>avoid</i> using arrow functions when using <span id="code">this</span> in a method!</p>

    <h2>Privacy</h2>

    <p>Accessing and updating properties is fundamental in working with objects. However, there are cases in which we don't want other code simply accessing and updating an object's properties. When discussing <i>privacy</i> in objects, we define it as the idea that only certain properties should be mutable or able to change in value.</p>

    <p>Certain languages have privacy built-in for objects, but JavaScirpt does not have this feature. Rather, JavaScirpt developers follow naming conventions that signal to other developers how to interact with a property. One common convention is to place an underscore <span id="code">_</span> before the name of a property to mean that the property should be altered. Here's an example of using <span id="code">_</span> to prepend a property.</p>

    <pre>
    <code>
        const bankAccount = {
            _amount: 1000
        }
    </code>
    </pre>

    <p>In the example above, the <span id="code">_amount</span> is not intended to be directly manipulated.</p>

    <p>Even so, it is still possible to reassign <span id="code">_amount</span>:</p>

    <pre>
    <code>
        bankAccount._amount = 1000000;
    </code>
    </pre>

    <p>In later exercises, we will talk about the use of methods called <i>getters</i> and <i>setters</i>. Both methods are used to respect the intention of properties prepended, or began, with <span id="code">_</span>.Getters can return the value of internal properties and setters can safely reassign property values.</p>

    <h2>Getters</h2>

    <p><i>Getters</i> are methods that get and return the internal properties of an object. But they can do more then just retrieve the value of a property! Let's take a look at a getter method:</p>

    <pre>
    <code>
        const person = {
            _firstName: 'John',
            _lastName: 'Doe',
            get fullName() {
              if (this._firstName && this._lastName){
                return `${this._firstName} ${this._lastName}`;
              } else {
                return 'Missing a first name or a last name.';
              }
            }
        }
          
        // To call the getter method: 
        person.fullName; // 'John Doe'
    </code>
    </pre>

    <p>Notice that in the getter method above:</p>

    <ul>
        <li>We use the <span id="code">get</span> keyword followed by a function.</li>
        <br>
        <li>We use an <span id="code">if...else</span> conditional to check if both <span id="code">_firstName</span> and <span id="code">_lastName</span> exist (by making sure they both return truthy values) and then return a different value depending on the result.</li>
        <br>
        <li>We can access the calling object's internal properties using <span id="code">this</span>. In <span id="code">fullName</span>, we're accessing both <span id="code">this._fullName</span> and <span id="code">this._lastName</span>.</li>
        <br>
        <li>In the last line we call <span id="code">fullName</span> on <span id="code">person</span>. In general, getter methods do not need to be called with a set of parentheses. Syntactically, it looks like we are accessing a property.</li>
    </ul>

    <p>Now that we have gone over syntax, let's discuss some notable advantages of using the getter methods:</p>

    <ul>
        <li>Getters can perfom an action on the data when getting a property.</li>
        <br>
        <li>Getters can return different values using conditionals.</li>
        <br>
        <li>In a getter, we can access the properties of the calling object using <span id="code">this</span>.</li>
        <br>
        <li>The functionality of our code is easier for other developers to understand.</li>
    </ul>

    <p>Another thing to keep in mind when using getter (and setters) methods is that properties cannot share the same name as the getter/setter function. If we do so, then calling the method wll result in an infinite call stack error. One work around is to add an underscore before the property name like we did in the example above.</p>

    <h2></h2>


<script src="JS/myScript.js"></script>   
</body>
<footer>
</footer>
</html>